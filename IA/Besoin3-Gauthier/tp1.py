# -*- coding: utf-8 -*-
"""TP1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1teAt_wyMrBDB18weDWPfvkmCBanWl494
"""

from google.colab import drive
drive.mount("/content/gdrive/")

"""#préparation des données

###1- Informations sur les données
"""

import os
print(os.getcwd())

import pandas as pd

DataFrame = pd.read_csv('/content/gdrive/MyDrive/INTELIENGE_AVEC_LENNEMI/TP_IA/TP1/housing.csv')
print(type(DataFrame))

print(DataFrame.head())

"""Sachant que la valeur cible à prédire est "median_house_value", il s'agit d'un problème de classification ou de régression ? --> Régréssion, on cherche une valeur"""

print(DataFrame.info())

"""Qu'est ce que vous remarquez à propos de l'attribut "total_bedrooms" par rapport aux autres attributs --> Il semble manquer des valeurs

c. Qu'est ce que vous remarquez à propos de l'attribut "ocean_proximity" par rapport aux autres attributs ? --> le Dtype de object
"""

DataFrame["ocean_proximity"].value_counts()

print(DataFrame.describe())

corr_matrix = DataFrame.corr(numeric_only = True)
print(corr_matrix["median_house_value"])

""" ### 2- Répartition des données"""

from sklearn.model_selection import train_test_split
train_set, test_set = train_test_split(DataFrame, test_size=0.2, random_state=42)
print(f"Taille de l'ensemble d'apprentissage : {len(train_set)}")
print(f"Taille de l'ensemble de test : {len(test_set)}")

print(test_set.head())

"""### 3- Nettoyage des données"""

features = train_set.drop("median_house_value", axis=1)  # Supprimer la colonne cible
target = train_set["median_house_value"].copy()  # Copier uniquement la colonne cible

print(features.head())
print(target.head())

median_total_bedrooms = features["total_bedrooms"].median()  # Calcul de la médiane
features["total_bedrooms"].fillna(median_total_bedrooms, inplace=True)  # Remplacement des NaN

print(features.info())

print(features["ocean_proximity"].value_counts())

# Importer la classe OrdinalEncoder
from sklearn.preprocessing import OrdinalEncoder
# Extraire la colonne 'ocean_proximity' pour la transformer
housing_cat = features[["ocean_proximity"]]
# Créer un objet OrdinalEncoder
encoder = OrdinalEncoder()
# Appliquer la transformation
housing_cat_encoded = encoder.fit_transform(housing_cat)
# Remplacer les anciennes valeurs textuelles par les nouvelles valeurs numériques
features["ocean_proximity"] = housing_cat_encoded
# Afficher les dix premières instances pour vérifier
print(features.head(10))

"""# II- Sélection et apprentissage du modèle

###1- Apprentissage des données
"""

# Importer la classe LinearRegression
from sklearn.linear_model import LinearRegression
# Créer un objet de la classe LinearRegression
lin_reg = LinearRegression()
# Appliquer la méthode fit sur les données d'apprentissage
lin_reg.fit(features, target)

"""###2- Evaluation du modèle d'apprentissage sur les données d'apprentissage"""

# Prédire les valeurs cibles à partir des données d'apprentissage
predictions = lin_reg.predict(features)

# Afficher les 5 premières valeurs réelles et prédites
print("Valeurs réelles :")
print(target.head().values)  # Les 5 premières valeurs réelles
print("\nValeurs prédites :")
print(predictions[:5])  # Les 5 premières valeurs prédites

from sklearn.metrics import mean_squared_error
import numpy as np

# Calcul de la MSE
mse = mean_squared_error(target, predictions)

# Calcul de la RMSE
rmse = np.sqrt(mse)

print(f"RMSE du modèle de régression linéaire : {rmse}")

from sklearn.tree import DecisionTreeRegressor
from sklearn.metrics import mean_squared_error
import numpy as np

# 1. Créer un objet de la classe DecisionTreeRegressor
tree_reg = DecisionTreeRegressor()

# 2. Ajuster le modèle sur les données d'apprentissage
tree_reg.fit(features, target)

# 3. Faire des prédictions sur les mêmes données d'apprentissage
tree_predictions = tree_reg.predict(features)

# 4. Calculer la MSE
tree_mse = mean_squared_error(target, tree_predictions)

# 5. Calculer la RMSE
tree_rmse = np.sqrt(tree_mse)

print(f"RMSE du modèle DecisionTreeRegressor : {tree_rmse}")

"""# 3- Evaluation du modèle d'apprentissage sur les données de validation"""

from sklearn.model_selection import cross_val_score
from sklearn.tree import DecisionTreeRegressor
import numpy as np

# Créer un objet de la classe DecisionTreeRegressor
tree_reg = DecisionTreeRegressor()

# Effectuer la validation croisée 3-fold avec la mesure de MSE
scores = cross_val_score(tree_reg, features, target, scoring="neg_mean_squared_error", cv=3)

# Convertir les scores négatifs en positifs et calculer la racine carrée pour obtenir la RMSE
rmse_scores = np.sqrt(-scores)

# Afficher la RMSE pour chaque pli
print("RMSE pour chaque pli : ", rmse_scores)

# Calculer et afficher la moyenne des RMSE
print("RMSE moyenne : ", rmse_scores.mean())

# Calculer et afficher l'écart-type des RMSE
print("Écart-type des RMSE : ", rmse_scores.std())

from sklearn.linear_model import LinearRegression
from sklearn.model_selection import cross_val_score
import numpy as np

# Créer un objet de la classe LinearRegression
lin_reg = LinearRegression()

# Effectuer la validation croisée 3-fold avec la mesure de MSE
scores = cross_val_score(lin_reg, features, target, scoring="neg_mean_squared_error", cv=3)

# Convertir les scores négatifs en positifs et calculer la racine carrée pour obtenir la RMSE
rmse_scores = np.sqrt(-scores)

# Afficher la RMSE pour chaque pli
print("RMSE pour chaque pli (Régression Linéaire) : ", rmse_scores)

# Calculer et afficher la moyenne des RMSE
print("RMSE moyenne (Régression Linéaire) : ", rmse_scores.mean())

# Calculer et afficher l'écart-type des RMSE
print("Écart-type des RMSE (Régression Linéaire) : ", rmse_scores.std())

"""31. Quel modèle présente le problème de sur-apprentissage ? Pourquoi ? il s'addapte trop aux données, même le bruit

# III- Fine-tuning

#1- Grid Search
"""